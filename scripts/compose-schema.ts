/**
 * Schema Composition Script
 * 
 * Composes domain schemas into a single root schema.graphql file
 * for AppSync deployment. Merges multiple Query types into one.
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, '..');
const SCHEMA_OUTPUT = path.join(ROOT_DIR, 'schema', 'schema.graphql');
const DOMAINS_DIR = path.join(ROOT_DIR, 'domains');

interface DomainSchema {
  domain: string;
  schemaPath: string;
}

function findDomainSchemas(): DomainSchema[] {
  const schemas: DomainSchema[] = [];
  const domains = fs.readdirSync(DOMAINS_DIR, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  for (const domain of domains) {
    const schemaPath = path.join(DOMAINS_DIR, domain, 'api', 'schema.graphql');
    if (fs.existsSync(schemaPath)) {
      schemas.push({ domain, schemaPath });
    }
  }

  return schemas;
}

/**
 * Extracts Query fields from a schema string
 */
function extractQueryFields(schemaContent: string): string[] {
  const queryFields: string[] = [];
  
  // Match type Query { ... } blocks
  const queryTypeRegex = /type\s+Query\s*\{([^}]+)\}/gs;
  const matches = schemaContent.matchAll(queryTypeRegex);
  
  for (const match of matches) {
    const queryBody = match[1];
    // Extract individual field definitions (lines that aren't just comments or whitespace)
    const lines = queryBody.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      // Skip empty lines and comment-only lines
      if (trimmed && !trimmed.startsWith('#')) {
        queryFields.push(trimmed);
      }
    }
  }
  
  return queryFields;
}

/**
 * Removes Query type definition from schema content
 */
function removeQueryType(schemaContent: string): string {
  // Remove type Query { ... } blocks (including comments before them)
  return schemaContent.replace(/type\s+Query\s*\{[^}]*\}/gs, '').trim();
}

function composeSchema(): void {
  const domainSchemas = findDomainSchemas();
  
  if (domainSchemas.length === 0) {
    throw new Error('No domain schemas found');
  }

  const sections: string[] = [];
  const allQueryFields: string[] = [];
  
  // Add header comment
  sections.push('# Composed GraphQL Schema');
  sections.push('# This file is auto-generated by scripts/compose-schema.ts');
  sections.push('# Do not edit this file directly. Edit domain schemas instead.');
  sections.push('');
  
  // Process domain schemas - extract types and Query fields
  for (const { domain, schemaPath } of domainSchemas) {
    sections.push(`# === ${domain.toUpperCase()} DOMAIN ===`);
    const content = fs.readFileSync(schemaPath, 'utf-8');
    
    // Extract Query fields
    const queryFields = extractQueryFields(content);
    allQueryFields.push(...queryFields);
    
    // Remove Query type and add the rest
    const contentWithoutQuery = removeQueryType(content);
    sections.push(contentWithoutQuery);
    sections.push('');
  }
  
  // Add merged Query type (after all other types)
  if (allQueryFields.length > 0) {
    sections.push('type Query {');
    // Add all query fields with proper indentation
    for (const field of allQueryFields) {
      sections.push(`  ${field}`);
    }
    sections.push('}');
    sections.push('');
  }
  
  // Add schema declaration
  sections.push('schema {');
  sections.push('  query: Query');
  sections.push('}');
  
  const composedSchema = sections.join('\n');
  
  // Ensure output directory exists
  const outputDir = path.dirname(SCHEMA_OUTPUT);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Write composed schema
  fs.writeFileSync(SCHEMA_OUTPUT, composedSchema, 'utf-8');
  
  console.log(`✓ Composed schema from ${domainSchemas.length} domain(s):`);
  domainSchemas.forEach(({ domain }) => console.log(`  - ${domain}`));
  console.log(`✓ Output: ${SCHEMA_OUTPUT}`);
}

// Run composition
composeSchema();
